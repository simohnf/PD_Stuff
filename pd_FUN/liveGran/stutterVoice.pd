#N canvas 0 23 974 823 10;
#X obj 139 681 *~, f 16;
#X obj 139 615 / 127;
#X obj 139 636 pack 0 5;
#X obj 139 657 line~;
#X obj 406 283 samphold~;
#X obj 457 251 wrap~;
#X obj 391 537 +~;
#X obj 391 558 *~ 1000;
#X obj 234 126 wrap~;
#X obj 285 405 *~;
#X obj 300 361 *~ 2;
#X obj 475 501 pow -1;
#X obj 475 522 * 60000;
#X floatatom 475 543 5 0 0 0 - - -;
#X obj 234 105 *~ 60;
#X obj 406 332 *~ 60, f 7;
#X obj 300 384 samphold~, f 10;
#N canvas 0 23 450 300 stutterLogic 0;
#X obj 101 50 inlet~;
#X obj 32 88 samphold~;
#X obj 32 63 noise~;
#X obj 32 133 expr~ $v1 < $f2;
#X obj 32 109 abs~;
#X obj 130 92 r \$1-stutter_snd;
#X obj 32 154 outlet~;
#X connect 0 0 1 1;
#X connect 1 0 4 0;
#X connect 2 0 1 0;
#X connect 3 0 6 0;
#X connect 4 0 3 0;
#X connect 5 0 3 1;
#X restore 232 398 pd stutterLogic;
#X f 7;
#N canvas 0 23 450 300 reverseLogic 0;
#X obj 101 50 inlet~;
#X obj 32 88 samphold~;
#X obj 32 63 noise~;
#X obj 32 133 expr~ $v1 < $f2;
#X obj 32 109 abs~;
#X obj 32 154 outlet~;
#X obj 130 92 r \$1-reverse_snd;
#X connect 0 0 1 1;
#X connect 1 0 4 0;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 6 0 3 1;
#X restore 300 316 pd reverseLogic;
#X f 7;
#X obj 232 579 *~, f 27;
#X obj 406 420 wrap~;
#N canvas 0 23 1238 770 phaseEnv_sjf~ 0;
#X obj 37 37 inlet~;
#X obj 37 436 cos~;
#X obj 37 307 clip~ 0 1;
#X obj 532 462 cos~;
#X obj 532 368 clip~ 0 1;
#X obj 532 400 *~ 0.25;
#X obj 532 431 +~ 0.25;
#X obj 37 366 *~ 0.25;
#X obj 37 405 -~ 0.25;
#X obj 532 309 -~;
#X obj 37 193 *~;
#X text 35 16 phase (0--> 1);
#X text 194 16 phase period;
#X text 285 16 envelope length;
#X text 221 156 nSegments;
#X text 337 135 1 - This calculation gives us the number of times the
length of our envelope fits into the phase loop. We use this to divide
the phase ramp into n segments;
#X obj 311 545 outlet~;
#X text 362 543 Envelope out;
#X text 41 244 ramp up;
#X text 96 289 we only want to take the first segment of the ramp (now
0--> nSegments) for out ramp up (i.e. attack);
#X text 95 319 When clip~ receives signals above 1 it outputs 1;
#X text 530 256 ramp down;
#X text 572 279 we only want to take the last segment of the ramp (now
0--> nSegments) for out ramp down (i.e. release);
#X text 570 309 This looks complicated but essentially we are just
shifting our ramp from a range of 0-->nSegments;
#X text 569 330 to a new range of -1*(nSegments-1) --> 1;
#X floatatom 975 297 5 0 10 0 - - -;
#X obj 1029 353 - 1;
#X obj 975 353 -;
#X floatatom 975 374 5 0 0 0 - - -;
#X msg 1028 322 10;
#X obj 975 317 t f b;
#X text 935 318 ---->;
#X text 941 329 e.g.;
#X text 1008 296 this goes from 0 --> 10;
#X text 1012 374 this goes from -9 --> 1;
#X text 598 366 When clip~ receives signals below 0 it outputs 0;
#X text 588 398 We only want to read through 1/4 of the total phase
of a cosine.;
#X text 85 393 For our attack we want the final 1/4 when the wave goes
from 0->1;
#X text 86 357 We only want to read through 1/4 of the total phase
of a cosine.;
#X text 588 433 For our decay we want the second 1/4 when the wave
goes from 0->-1;
#X text 71 437 The signal here goes from minimum 0 to maximum 1;
#X text 564 464 The signal here goes from maximum 0 to minimum -1;
#X text 458 507 ramp up only changes during the first segment (when
ramp down is at 0) ==> the sum of both is ramp up (going 0-->1) + ramp
down (static 0). Anything + 0 is 0 ==> the output is the ramp up;
#X text 457 561 ramp down only changes during the final segment (when
ramp up is at 1) ==> the sum of both is ramp down (going 0--> -1) +
ramp up (static 1). there fore the output is goes from 1 --> 0 as ramp
down goes 0--> -1;
#X text 1007 714 sjf \, SAE London \, 2020;
#X text 821 14 This is a clever idea I stole from the grooveduck example
in MaxMSP (which is by jhno I think...);
#X text 821 38 It takes a phase ramp in (e.g. the full phase for reading
a file from tabread~ \, and outputs a sine wave based amplitude ramp
at the beginning and end;
#X text 821 75 phase period and envelope lenth can be in samples or
ms or s or hrs... as long as they are both given in the same unit;
#X text 62 191 2 - by multiplying the ramp (0-->1) by nSegments \,
we get a new ramp that goes 0 --> nSegments;
#X obj 204 37 inlet~;
#X obj 546 288 -~ 1;
#X obj 204 136 *~, f 21;
#X obj 301 37 inlet~;
#X obj 331 88 samphold~;
#X obj 284 106 min~, f 8;
#X obj 284 88 *~ 0.5;
#X connect 0 0 10 0;
#X connect 0 0 53 1;
#X connect 1 0 16 0;
#X connect 2 0 7 0;
#X connect 3 0 16 0;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 6 0 3 0;
#X connect 7 0 8 0;
#X connect 8 0 1 0;
#X connect 9 0 4 0;
#X connect 10 0 2 0;
#X connect 10 0 9 0;
#X connect 25 0 30 0;
#X connect 26 0 27 1;
#X connect 27 0 28 0;
#X connect 29 0 26 0;
#X connect 30 0 27 0;
#X connect 30 1 29 0;
#X connect 49 0 55 0;
#X connect 49 0 51 0;
#X connect 50 0 9 1;
#X connect 51 0 10 1;
#X connect 51 0 50 0;
#X connect 52 0 53 0;
#X connect 53 0 54 1;
#X connect 54 0 51 1;
#X connect 55 0 54 0;
#X restore 659 482 pd phaseEnv_sjf~;
#X obj 445 312 r \$1-bpm_snd;
#X obj 692 172 r \$1-bpm_snd;
#X obj 475 477 r \$1-bpm_snd;
#X obj 279 87 r \$1-bpm_snd;
#X obj 406 401 *~ 0.5;
#X obj 406 441 *~ 2, f 7;
#X obj 498 103 samphold~;
#X obj 498 72 noise~;
#X obj 498 124 abs~;
#X obj 457 230 *~;
#X obj 232 643 *~, f 63;
#X text 488 223 <-- beats in a minute;
#X text 705 237 <-- ioi;
#X obj 497 197 expr~ $f2*(round($v1)+1) \; pow($v1 \, -1)*60000/$f2
, f 35;
#X obj 741 435 pow -1;
#X obj 741 459 sig~ 1;
#X obj 139 730 hip~ 100;
#X obj 203 731 lop~ 100;
#X obj 741 409 r \$1-ramp_snd;
#X obj 217 700 r \$1-xover_snd;
#X obj 409 6 inlet~;
#X text 464 47 phase ramp in;
#X obj 139 751 outlet~;
#X obj 203 752 outlet~;
#X obj 139 589 r \$1-vol_snd;
#X obj 659 392 *~ 1;
#X obj 357 286 *~ 1;
#X obj 498 145 *~;
#X obj 498 175 *~ 7;
#X obj 466 392 r \$1-maxStutDepth_snd;
#X obj 466 426 pow -1;
#X obj 232 602 vd~ \$1-lG_\$2;
#X obj 614 392 wrap~;
#X obj 575 426 sig~ 1;
#X obj 575 447 -~, f 8;
#X obj 620 421 *~;
#X obj 607 516 *~;
#X obj 406 462 +~ 1;
#X connect 0 0 38 0;
#X connect 0 0 39 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 0 0;
#X connect 4 0 15 0;
#X connect 5 0 4 1;
#X connect 5 0 47 0;
#X connect 5 0 48 0;
#X connect 6 0 7 0;
#X connect 7 0 19 1;
#X connect 8 0 9 0;
#X connect 8 0 17 0;
#X connect 8 0 28 1;
#X connect 9 0 6 0;
#X connect 10 0 16 0;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 13 0 7 1;
#X connect 14 0 8 0;
#X connect 15 0 26 0;
#X connect 15 0 54 0;
#X connect 16 0 9 1;
#X connect 17 0 19 0;
#X connect 18 0 10 0;
#X connect 19 0 53 0;
#X connect 20 0 27 0;
#X connect 21 0 58 1;
#X connect 22 0 15 1;
#X connect 23 0 35 1;
#X connect 24 0 11 0;
#X connect 25 0 14 1;
#X connect 26 0 20 0;
#X connect 27 0 59 0;
#X connect 28 0 30 0;
#X connect 29 0 28 0;
#X connect 30 0 49 0;
#X connect 30 0 49 1;
#X connect 31 0 5 0;
#X connect 32 0 0 1;
#X connect 35 0 31 1;
#X connect 35 1 21 1;
#X connect 36 0 37 0;
#X connect 37 0 21 2;
#X connect 38 0 44 0;
#X connect 39 0 45 0;
#X connect 40 0 36 0;
#X connect 41 0 38 1;
#X connect 41 0 39 1;
#X connect 42 0 14 0;
#X connect 42 0 4 0;
#X connect 42 0 31 0;
#X connect 46 0 1 0;
#X connect 47 0 21 0;
#X connect 48 0 18 0;
#X connect 48 0 16 1;
#X connect 49 0 50 0;
#X connect 50 0 35 0;
#X connect 51 0 52 0;
#X connect 51 0 27 1;
#X connect 52 0 26 1;
#X connect 53 0 32 0;
#X connect 54 0 57 0;
#X connect 54 0 57 1;
#X connect 55 0 56 0;
#X connect 56 0 58 0;
#X connect 57 0 56 1;
#X connect 58 0 32 1;
#X connect 59 0 6 1;
