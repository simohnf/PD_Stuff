#N canvas 0 23 1280 751 10;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-sample 209801 float 2;
#X coords 0 1 209801 -1 300 150 1 0 0;
#X restore 615 68 graph;
#X obj 636 293 openpanel;
#X obj 636 272 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 636 315 pack s \$0;
#X msg 636 339 read -resize \$1 \$2-sample;
#X text 657 269 <--- load a different file;
#X obj 636 359 soundfiler;
#X obj 636 380 s \$0-sample_len;
#X msg 901 302 ./breaks/funkyDrummer.wav;
#X msg 901 321 ./breaks/amenBreak.wav;
#X msg 901 340 ./breaks/PlanetaryCitizen.wav;
#X floatatom 529 481 10 0 0 0 - - -;
#X obj 110 582 vol_sjf~;
#X text 186 605 <---- turn me up;
#X text 531 442 File size in samples;
#X obj 529 462 r \$0-sample_len;
#X floatatom 566 240 5 1 64 0 nSlices #0-nSlices_rec #0-nSlices_snd
;
#X obj 509 429 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#N canvas 0 22 450 278 (subpatch) 0;
#X array \$0-slicePat 18 float 3;
#A 0 -0.00714296 0 0.0625 0.125 0.1875 0.25 0.3125 0.375 0.4375 0.5
0.5625 0.625 0.6875 0.75 0.8125 0.875 0.9375 0;
#X coords 0 1 18 0 200 140 1 0 0;
#X restore 13 149 graph;
#X obj 111 353 phasor~;
#X obj 598 136 tgl 15 1 \$0-on/off_snd \$0-on/off_rec on/off -36 7
0 10 -262144 -1 -1 0 1;
#X floatatom 181 134 5 1 64 0 nSteps #0-nSteps_rec #0-nSteps_snd;
#X obj 592 598 s \$0-sliceSizeSamps, f 9;
#N canvas 0 23 450 278 (subpatch) 0;
#X array \$0-subDivPat 18 float 3;
#A 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#X coords 0 1 18 0 150 35 1 0 0;
#X restore 213 149 graph;
#X text 160 351 Rather than play for full length of file \, phasor~
;
#X text 161 363 frequency is ( 1 / (nSteps * spliceLength));
#X text 156 378 This means Phasor~ loops once every repetition of the
pattern;
#X obj 537 598 s \$0-sliceSizeSec, f 8;
#N canvas 0 23 450 278 (subpatch) 0;
#X array \$0-speedPat 18 float 3;
#A 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.171429;
#X coords 0 1 18 0 150 35 1 0 0;
#X restore 363 149 graph;
#N canvas 0 23 450 278 (subpatch) 0;
#X array \$0-revPat 18 float 3;
#A 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#X coords 0 1 18 0 150 35 1 0 0;
#X restore 213 199 graph;
#N canvas 0 23 922 300 resize_pattern 0;
#X obj 34 9 r \$0-nSteps_snd;
#X obj 34 30 + 2;
#X obj 33 61 array size \$0-slicePat;
#X obj 195 60 array size \$0-subDivPat;
#X obj 341 61 array size \$0-speedPat;
#X obj 480 61 array size \$0-revPat;
#X obj 612 60 array size \$0-ampPat;
#X obj 741 60 array size \$0-trailTypePat;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 3 0;
#X connect 1 0 4 0;
#X connect 1 0 5 0;
#X connect 1 0 6 0;
#X connect 1 0 7 0;
#X restore 148 679 pd resize_pattern arrays;
#N canvas 0 23 450 278 (subpatch) 0;
#X array \$0-ampPat 18 float 3;
#A 0 -1.78814e-07 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0;
#X coords 0 1 18 0 150 35 1 0 0;
#X restore 213 254 graph;
#N canvas 0 23 450 278 (subpatch) 0;
#X array \$0-trailTypePat 18 float 3;
#A 0 -0.0285705 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#X coords 0 1 18 0 150 35 1 0 0;
#X restore 363 199 graph;
#N canvas 387 226 893 548 randomisers 0;
#N canvas 321 59 508 376 randomiser 0;
#X obj 74 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 77 234 outlet;
#X obj 272 32 inlet;
#X obj 7 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 141 29 inlet;
#X text 268 13 nSteps;
#X text 142 8 nSlices;
#X text 3 25 orig;
#X text 66 25 rand;
#X floatatom 272 53 5 0 0 0 - - -;
#X floatatom 141 50 5 0 0 0 - - -;
#X obj 39 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X text 35 25 rev;
#N canvas 0 23 450 300 originalPattern 0;
#X obj 17 36 inlet;
#X obj 18 246 pack;
#X obj 18 110 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 18 129 pd simpleCounter;
#X obj 18 197 + 1;
#X obj 18 65 int 8, f 45;
#X obj 18 149 t f f, f 12;
#X obj 84 197 /;
#X obj 18 89 t f b f, f 10;
#X obj 84 175 %;
#X obj 18 267 outlet;
#X text 15 17 bang;
#X obj 281 27 inlet;
#X text 279 8 nSteps;
#X obj 170 147 inlet;
#X text 168 128 nSlices;
#X connect 0 0 5 0;
#X connect 1 0 10 0;
#X connect 2 0 3 0;
#X connect 3 0 6 0;
#X connect 4 0 1 0;
#X connect 5 0 8 0;
#X connect 6 0 4 0;
#X connect 6 1 9 0;
#X connect 7 0 1 1;
#X connect 8 0 2 0;
#X connect 8 1 3 1;
#X connect 8 2 3 2;
#X connect 9 0 7 0;
#X connect 12 0 5 1;
#X connect 14 0 9 1;
#X connect 14 0 7 1;
#X restore 7 97 pd originalPattern;
#N canvas 0 23 328 381 reversePattern 0;
#X obj 26 35 inlet;
#X obj 26 326 outlet;
#X text 24 16 bang;
#X obj 217 28 inlet;
#X text 215 9 nSteps;
#X obj 155 144 inlet;
#X text 153 125 nSlices;
#X obj 26 303 pack;
#X obj 26 107 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 26 126 pd simpleCounter;
#X obj 26 262 + 1;
#X obj 26 62 int 8, f 32;
#X obj 26 146 t f f, f 12;
#X obj 92 268 /, f 11;
#X obj 26 86 t f b f, f 10;
#X obj 92 172 %;
#X obj 92 193 t b f;
#X obj 92 225 int;
#X obj 92 246 -, f 5;
#X obj 130 193 - 1;
#X connect 0 0 11 0;
#X connect 3 0 11 1;
#X connect 5 0 19 0;
#X connect 5 0 15 1;
#X connect 5 0 13 1;
#X connect 7 0 1 0;
#X connect 8 0 9 0;
#X connect 9 0 12 0;
#X connect 10 0 7 0;
#X connect 11 0 14 0;
#X connect 12 0 10 0;
#X connect 12 1 15 0;
#X connect 13 0 7 1;
#X connect 14 0 8 0;
#X connect 14 1 9 1;
#X connect 14 2 9 2;
#X connect 15 0 16 0;
#X connect 16 0 17 0;
#X connect 16 1 18 1;
#X connect 17 0 18 0;
#X connect 18 0 13 0;
#X connect 19 0 17 1;
#X restore 123 97 pd reversePattern;
#N canvas 0 23 328 381 randPattern 0;
#X obj 26 35 inlet;
#X obj 26 326 outlet;
#X text 24 16 bang;
#X obj 217 28 inlet;
#X text 215 9 nSteps;
#X obj 70 241 pack;
#X obj 70 171 t f b;
#X obj 70 123 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 70 142 pd simpleCounter;
#X obj 70 102 t f f 0, f 16;
#X obj 101 194 random 10000;
#X obj 101 215 / 10000;
#X obj 70 192 + 1;
#X obj 79 78 int 8;
#X connect 0 0 13 0;
#X connect 3 0 13 1;
#X connect 5 0 1 0;
#X connect 6 0 12 0;
#X connect 6 1 10 0;
#X connect 7 0 8 0;
#X connect 8 0 6 0;
#X connect 9 0 7 0;
#X connect 9 1 8 1;
#X connect 9 2 8 2;
#X connect 10 0 11 0;
#X connect 11 0 5 1;
#X connect 12 0 5 0;
#X connect 13 0 9 0;
#X restore 247 100 pd randPattern;
#X obj 6 3 inlet;
#X obj 346 45 r \$0-rand_snd;
#X connect 0 0 15 0;
#X connect 2 0 9 0;
#X connect 2 0 14 2;
#X connect 2 0 13 2;
#X connect 2 0 15 1;
#X connect 3 0 13 0;
#X connect 4 0 10 0;
#X connect 4 0 14 1;
#X connect 4 0 13 1;
#X connect 11 0 14 0;
#X connect 13 0 1 0;
#X connect 14 0 1 0;
#X connect 15 0 1 0;
#X connect 16 0 3 0;
#X connect 17 0 15 0;
#X coords 0 -1 1 1 100 60 1 0 0;
#X restore 100 118 pd randomiser;
#X msg 100 183 \$2 \$1;
#X obj 100 204 unpack;
#X msg 157 319 \$2 \$1;
#X obj 157 342 unpack;
#N canvas 321 59 450 300 randomiser 0;
#X obj 11 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 11 240 pack;
#X obj 11 262 outlet;
#X text 3 24 Random Pattern;
#X obj 11 170 t f b;
#X obj 11 122 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 11 141 pd simpleCounter;
#X obj 11 101 t f f 0, f 16;
#X obj 42 193 random 10000;
#X obj 42 214 / 10000;
#X obj 11 191 + 1;
#X obj 20 77 int 8;
#X obj 54 60 inlet;
#X obj 8 5 r \$0-rand_snd;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 4 0 10 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X connect 7 0 5 0;
#X connect 7 1 6 1;
#X connect 7 2 6 2;
#X connect 8 0 9 0;
#X connect 9 0 1 1;
#X connect 10 0 1 0;
#X connect 11 0 7 0;
#X connect 12 0 11 1;
#X connect 13 0 0 0;
#X coords 0 -1 1 1 100 60 1 0 0;
#X restore 200 118 pd randomiser;
#X obj 157 363 expr pow($f1 \, $f2);
#X floatatom 242 157 5 1 100 0 - #0-randPow_rec -;
#X obj 157 291 t l b;
#X obj 157 434 tabwrite \$0-subDivPat;
#X obj 42 242 tabwrite \$0-slicePat;
#X msg 296 217 \$2 \$1;
#X obj 296 240 unpack;
#N canvas 321 59 450 300 randomiser 0;
#X obj 11 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 11 240 pack;
#X obj 11 262 outlet;
#X text 3 24 Random Pattern;
#X obj 11 170 t f b;
#X obj 11 122 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 11 141 pd simpleCounter;
#X obj 11 101 t f f 0, f 16;
#X obj 42 193 random 10000;
#X obj 42 214 / 10000;
#X obj 11 191 + 1;
#X obj 20 77 int 8;
#X obj 54 60 inlet;
#X obj 9 4 r \$0-rand_snd;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 4 0 10 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X connect 7 0 5 0;
#X connect 7 1 6 1;
#X connect 7 2 6 2;
#X connect 8 0 9 0;
#X connect 9 0 1 1;
#X connect 10 0 1 0;
#X connect 11 0 7 0;
#X connect 12 0 11 1;
#X connect 13 0 0 0;
#X coords 0 -1 1 1 100 60 1 0 0;
#X restore 300 118 pd randomiser;
#X obj 296 261 expr pow($f1 \, $f2);
#X floatatom 338 158 5 1 100 0 - #0-randPow_rec -;
#X obj 296 189 t l b;
#X obj 296 332 tabwrite \$0-speedPat;
#X msg 511 213 \$2 \$1;
#X obj 511 236 unpack;
#N canvas 321 59 450 300 randomiser 0;
#X obj 11 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 11 240 pack;
#X obj 11 262 outlet;
#X text 3 24 Random Pattern;
#X obj 11 170 t f b;
#X obj 11 122 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 11 141 pd simpleCounter;
#X obj 11 101 t f f 0, f 16;
#X obj 42 193 random 10000;
#X obj 42 214 / 10000;
#X obj 11 191 + 1;
#X obj 20 77 int 8;
#X obj 54 60 inlet;
#X obj 9 4 r \$0-rand_snd;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 4 0 10 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X connect 7 0 5 0;
#X connect 7 1 6 1;
#X connect 7 2 6 2;
#X connect 8 0 9 0;
#X connect 9 0 1 1;
#X connect 10 0 1 0;
#X connect 11 0 7 0;
#X connect 12 0 11 1;
#X connect 13 0 0 0;
#X coords 0 -1 1 1 100 60 1 0 0;
#X restore 500 118 pd randomiser;
#X obj 511 257 expr pow($f1 \, $f2);
#X floatatom 539 158 5 1 100 0 - #0-randPow_rec -;
#X obj 511 185 t l b;
#X obj 511 328 tabwrite \$0-revPat;
#X msg 433 371 \$2 \$1;
#X obj 433 394 unpack;
#N canvas 321 59 450 300 randomiser 0;
#X obj 11 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 11 240 pack;
#X obj 11 262 outlet;
#X text 3 24 Random Pattern;
#X obj 11 170 t f b;
#X obj 11 122 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 11 141 pd simpleCounter;
#X obj 11 101 t f f 0, f 16;
#X obj 42 193 random 10000;
#X obj 42 214 / 10000;
#X obj 11 191 + 1;
#X obj 20 77 int 8;
#X obj 54 60 inlet;
#X obj 9 4 r \$0-rand_snd;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 4 0 10 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X connect 7 0 5 0;
#X connect 7 1 6 1;
#X connect 7 2 6 2;
#X connect 8 0 9 0;
#X connect 9 0 1 1;
#X connect 10 0 1 0;
#X connect 11 0 7 0;
#X connect 12 0 11 1;
#X connect 13 0 0 0;
#X coords 0 -1 1 1 100 60 1 0 0;
#X restore 400 118 pd randomiser;
#X floatatom 434 159 5 1 100 0 - #0-randPow_rec -;
#X obj 433 343 t l b;
#X obj 433 486 tabwrite \$0-ampPat;
#X obj 433 415 expr 1 - pow($f1 \, $f2);
#X text 122 129 slicePat;
#X text 217 132 subDivPat;
#X obj 261 3 loadbang;
#X text 324 131 speedPat;
#X text 420 131 ampPat;
#X text 521 130 revPat;
#X msg 671 219 \$2 \$1;
#X obj 671 242 unpack;
#N canvas 321 59 450 300 randomiser 0;
#X obj 11 40 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 11 240 pack;
#X obj 11 262 outlet;
#X text 3 24 Random Pattern;
#X obj 11 170 t f b;
#X obj 11 122 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 11 141 pd simpleCounter;
#X obj 11 101 t f f 0, f 16;
#X obj 42 193 random 10000;
#X obj 42 214 / 10000;
#X obj 11 191 + 1;
#X obj 20 77 int 8;
#X obj 54 60 inlet;
#X obj 9 4 r \$0-rand_snd;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 4 0 10 0;
#X connect 4 1 8 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X connect 7 0 5 0;
#X connect 7 1 6 1;
#X connect 7 2 6 2;
#X connect 8 0 9 0;
#X connect 9 0 1 1;
#X connect 10 0 1 0;
#X connect 11 0 7 0;
#X connect 12 0 11 1;
#X connect 13 0 0 0;
#X coords 0 -1 1 1 100 60 1 0 0;
#X restore 600 118 pd randomiser;
#X obj 671 191 t l b;
#X text 604 130 trailTypePat;
#X obj 670 333 tabwrite \$0-trailTypePat;
#X obj 405 63 inlet;
#X obj 177 42 inlet;
#X text 398 45 nsteps;
#X text 172 23 nslices;
#X obj 91 66 inlet;
#X text 90 37 original;
#X msg 261 24 50;
#X obj 261 45 s \$0-randPow_rec;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 10 0;
#X connect 2 1 10 1;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 4 1 9 1;
#X connect 5 0 8 0;
#X connect 6 0 9 0;
#X connect 7 0 6 1;
#X connect 8 0 3 0;
#X connect 11 0 12 0;
#X connect 12 0 14 0;
#X connect 12 1 17 1;
#X connect 13 0 16 0;
#X connect 14 0 17 0;
#X connect 15 0 14 1;
#X connect 16 0 11 0;
#X connect 18 0 19 0;
#X connect 19 0 21 0;
#X connect 19 1 24 1;
#X connect 20 0 23 0;
#X connect 21 0 24 0;
#X connect 22 0 21 1;
#X connect 23 0 18 0;
#X connect 25 0 26 0;
#X connect 26 0 31 0;
#X connect 26 1 30 1;
#X connect 27 0 29 0;
#X connect 28 0 31 1;
#X connect 29 0 25 0;
#X connect 31 0 30 0;
#X connect 34 0 50 0;
#X connect 38 0 39 0;
#X connect 39 0 43 0;
#X connect 39 1 43 1;
#X connect 40 0 41 0;
#X connect 41 0 38 0;
#X connect 44 0 0 2;
#X connect 44 0 5 0;
#X connect 44 0 13 0;
#X connect 44 0 20 0;
#X connect 44 0 27 0;
#X connect 44 0 40 0;
#X connect 45 0 0 1;
#X connect 48 0 0 0;
#X connect 50 0 51 0;
#X coords 0 -1 1 1 600 80 1 100 100;
#X restore 13 50 pd randomisers;
#X obj 606 6 r \$0-nSteps_snd;
#X obj 309 6 r \$0-nSlices_snd;
#N canvas 0 23 1005 300 sliceSizeLogic 0;
#X obj 226 35 inlet;
#X text 211 8 samp length (samps);
#X obj 192 91 / 44100;
#X floatatom 192 112 10 0 0 0 - - -;
#X text 26 111 size of the file in seconds;
#X obj 369 129 t b f;
#N canvas 0 23 450 300 1/\$1 0;
#X obj 93 65 t b f;
#X msg 93 86 1;
#X obj 93 107 /, f 5;
#X obj 95 39 inlet;
#X obj 93 128 outlet;
#X connect 0 0 1 0;
#X connect 0 1 2 1;
#X connect 1 0 2 0;
#X connect 2 0 4 0;
#X connect 3 0 0 0;
#X restore 369 108 pd 1/\$1;
#X obj 192 188 *, f 21;
#X text 96 188 splice size (s);
#X floatatom 149 208 5 0 0 0 - - -;
#X obj 192 216 outlet;
#X text 235 218 sliceSizeSec;
#X obj 548 170 *;
#X obj 548 120 t b f;
#X obj 548 89 - 2;
#X text 576 91 <--- according to tabread~ helpfile the indices end
at (file size - 2 samples) ???;
#X floatatom 625 201 10 0 0 0 - - -;
#X text 568 170 splice size samps;
#X obj 524 233 outlet;
#X text 567 235 sliceSizeSamps;
#X obj 372 34 inlet;
#X text 362 11 nSlices;
#X connect 0 0 2 0;
#X connect 0 0 14 0;
#X connect 2 0 3 0;
#X connect 3 0 7 0;
#X connect 5 0 7 0;
#X connect 5 1 7 1;
#X connect 5 1 12 0;
#X connect 6 0 5 0;
#X connect 7 0 9 0;
#X connect 7 0 10 0;
#X connect 12 0 16 0;
#X connect 12 0 18 0;
#X connect 13 0 12 0;
#X connect 13 1 12 1;
#X connect 14 0 13 0;
#X connect 20 0 6 0;
#X restore 537 574 pd sliceSizeLogic;
#X obj 657 573 r \$0-nSlices_snd, f 10;
#X floatatom 566 225 5 0 0 0 bpm #0-bpm_rec #0-bpm_snd;
#X floatatom 566 184 5 0.5 100 0 duckT #0-duckT_rec #0-duckT_snd;
#X obj 375 584 s \$0-tempoQuantize, f 8;
#X obj 598 154 bng 15 250 50 0 \$0-original_snd \$0-original_rec original
-40 7 0 8 -262144 -1 -1;
#X obj 386 631 f, f 21;
#X obj 429 584 r \$0-original_snd, f 11;
#X obj 386 713 s \$0-bpm_rec;
#X obj 406 536 r \$0-bpm_snd;
#N canvas 0 23 461 451 bpmQuatizeLogic 0;
#X obj 184 53 inlet;
#X obj 184 83 t b f;
#X obj 184 125 /, f 7;
#X msg 184 104 60;
#X floatatom 184 224 5 0 0 0 - - -;
#X text 97 225 original bpm;
#X obj 127 283 /;
#X obj 127 258 t b f;
#X obj 184 244 outlet;
#X text 223 242 original bpm;
#X text 173 29 slice size sec;
#X obj 41 81 inlet;
#X text 40 60 \$0-bpm_snd;
#X obj 127 306 outlet;
#X text 167 306 \$0-tempoQuantize;
#X obj 184 199 *, f 20;
#X obj 275 70 r \$0-sliceVal_snd;
#X obj 275 91 t b f;
#X msg 275 112 1;
#X obj 275 133 /, f 5;
#X obj 275 167 t b f;
#X floatatom 339 163 5 0 0 0 - - -;
#X floatatom 121 150 5 0 0 0 - - -;
#X obj 184 146 * 4;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 1 1 2 1;
#X connect 2 0 22 0;
#X connect 2 0 23 0;
#X connect 3 0 2 0;
#X connect 4 0 7 0;
#X connect 4 0 8 0;
#X connect 6 0 13 0;
#X connect 7 0 6 0;
#X connect 7 1 6 1;
#X connect 11 0 6 0;
#X connect 15 0 4 0;
#X connect 16 0 17 0;
#X connect 17 0 18 0;
#X connect 17 1 19 1;
#X connect 18 0 19 0;
#X connect 19 0 20 0;
#X connect 19 0 21 0;
#X connect 20 0 15 0;
#X connect 20 1 15 1;
#X connect 23 0 15 0;
#X restore 406 558 pd bpmQuatizeLogic;
#N canvas 294 52 1280 755 samplerLogic 0;
#X obj 11 59 inlet~;
#X obj 306 672 tabread4~ \$0-sample;
#X obj 306 630 +~, f 122;
#X obj 306 110 *~, f 14;
#X obj 92 676 *~, f 20;
#X obj 306 326 wrap~;
#X obj 305 466 wrap~;
#X obj 306 651 +~ 1;
#X obj 304 415 *~;
#X obj 153 64 * 1000;
#X text 398 109 by multiplying by nSteps I get a ramp from 0 --> nSteps
;
#X text 341 325 this gives us a repeated ramp of 0-->1 looping at the
beginning of each step;
#N canvas 1189 420 692 481 read_slice_playback_pattern 0;
#X obj 81 36 inlet~;
#X obj 163 195 inlet;
#X text 157 169 nSlices;
#X obj 242 361 inlet;
#X text 236 335 slice size in samps;
#X obj 81 401 *~;
#X obj 81 236 *~, f 14;
#X obj 81 288 expr~ floor($v1);
#X text 231 116 This is the pattern of splices;
#X text 177 234 convert from 0 --> 1 to 0--> nSlices;
#X text 188 283 this just ensures we only get integer values so we
always begin at the start of a slice);
#X text 188 307 therefore it outputs the splice number to jump to;
#X text 112 406 convert splice number to sample in audio file;
#X obj 81 422 outlet~;
#X obj 81 91 +~ 1;
#X text 7 20 phase ramp converted to 0--> nSteps;
#X text 114 88 tabread~ starts its indexing from 1 ????;
#X obj 81 58 expr~ floor($v1);
#X text 185 56 this just ensures we only get integer values (i.e. counting
numbers so we can count the beats);
#X obj 81 139 clip~ 0 1;
#X text 141 140 dont let out of bounds values through;
#X obj 81 120 tabread4~ \$0-slicePat;
#X connect 0 0 17 0;
#X connect 1 0 6 1;
#X connect 3 0 5 1;
#X connect 5 0 13 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X connect 14 0 21 0;
#X connect 17 0 14 0;
#X connect 19 0 6 0;
#X connect 21 0 19 0;
#X restore 941 173 pd read_slice_playback_pattern;
#N canvas 0 23 834 605 read_subDivPat 0;
#X obj 37 37 inlet~;
#X obj 34 445 expr~ floor($v1);
#X obj 34 424 *~ 8, f 14;
#X obj 34 506 +~ 1;
#X obj 34 403 clip~ 0 1;
#X obj 34 356 +~ 1;
#X text 64 357 tabread~ starts its indexing from 1 ????;
#X obj 205 140 expr~ floor($v1);
#X text 308 138 this just ensures we only get integer values (i.e.
counting numbers so we can count the beats);
#X text 94 404 dont let out of bounds values through;
#X text 125 423 I chose 8 as the maximum subdivision possible;
#X text 139 444 again \, I only want integer values (non integer values
would makes amplitude envelopes difficult...);
#X obj 34 382 tabread4~ \$0-subDivPat;
#X text 64 506 I want the minimum subdivision to be 1 times the length
of the segment (again this prevents amplitude envelope issues);
#X obj 34 547 outlet~;
#X obj 134 165 t b f;
#X msg 134 186 1;
#X obj 143 212 -;
#X obj 37 215 *~;
#X obj 204 270 *~ 1;
#X obj 69 140 r \$0-subDivramps_snd;
#X connect 0 0 7 0;
#X connect 0 0 18 0;
#X connect 1 0 3 0;
#X connect 2 0 1 0;
#X connect 3 0 14 0;
#X connect 4 0 2 0;
#X connect 5 0 12 0;
#X connect 7 0 19 0;
#X connect 12 0 4 0;
#X connect 15 0 16 0;
#X connect 15 1 17 1;
#X connect 16 0 17 0;
#X connect 17 0 19 1;
#X connect 18 0 5 0;
#X connect 19 0 5 0;
#X connect 20 0 15 0;
#X connect 20 0 18 1;
#X restore 731 335 pd read_subDivPat;
#X text 657 269 we get subdivisions of the beat;
#X text 659 280 by looping smaller sections with faster ramps;
#X obj 305 541 wrap~;
#X text 329 412 convert rampfrom 0 1 for each step to 0 --> nSubdivisons
;
#X text 339 465 0 --> 1 looping for eavery subdivision;
#X obj 306 693 *~, f 70;
#N canvas 0 23 602 395 convert_to_subdivSize(samps) 0;
#X obj 51 56 inlet~;
#X text 20 30 sub division phase (0 --> 1);
#X obj 279 62 inlet~;
#X text 243 33 sub division pattern value;
#X obj 51 216 *~, f 53;
#X obj 167 166 *~, f 47;
#X obj 167 138 /~, f 17;
#X obj 167 117 sig~ 1;
#X text 440 68 \$0-sliceSizeSamps;
#X obj 449 90 inlet;
#X obj 51 237 outlet~;
#X text 102 238 0 --> sub division size in samples;
#X connect 0 0 4 0;
#X connect 2 0 6 1;
#X connect 4 0 10 0;
#X connect 5 0 4 1;
#X connect 6 0 5 0;
#X connect 7 0 6 0;
#X connect 9 0 5 1;
#X restore 306 596 pd convert_to_subdivSize(samps);
#X f 51;
#N canvas 0 23 817 407 subDivisionRamp 0;
#X obj 63 56 inlet~;
#X obj 43 271 /~, f 12;
#X obj 199 139 +~ 1;
#X obj 199 79 expr~ floor($v1);
#X obj 112 247 expr~ pow($v1 \, $f2);
#X obj 364 133 -~;
#N canvas 833 152 537 386 read_trailTypePat 0;
#X obj 37 37 inlet~;
#X obj 38 201 clip~ 0 1;
#X obj 37 116 +~ 1;
#X text 67 117 tabread~ starts its indexing from 1 ????;
#X obj 37 61 expr~ floor($v1);
#X text 140 59 this just ensures we only get integer values (i.e. counting
numbers so we can count the beats);
#X text 98 202 dont let out of bounds values through;
#X obj 38 346 outlet~;
#X obj 38 246 expr~ round($v1);
#X obj 38 180 tabread4~ \$0-trailTypePat;
#X connect 0 0 4 0;
#X connect 1 0 8 0;
#X connect 2 0 9 0;
#X connect 4 0 2 0;
#X connect 8 0 7 0;
#X connect 9 0 1 0;
#X restore 63 78 pd read_trailTypePat;
#X obj 39 246 sig~ 1;
#X obj 43 292 outlet~;
#X text 41 313 amplify level for subdivisions (1--> 0);
#X obj 199 45 inlet~;
#X text 197 14 phase 0 --> nSubDivisions;
#X text 23 31 phase 0 --> nSteps;
#X obj 364 85 inlet~;
#X text 324 60 subDivision type;
#X obj 618 155 inlet;
#X text 615 127 subDivTrail exponent (0 --> );
#X obj 112 183 expr~ if($v1 == 0 \, $v2 \, $v3);
#X connect 0 0 6 0;
#X connect 1 0 8 0;
#X connect 2 0 17 1;
#X connect 3 0 2 0;
#X connect 3 0 5 1;
#X connect 4 0 1 1;
#X connect 5 0 17 2;
#X connect 6 0 17 0;
#X connect 7 0 1 0;
#X connect 10 0 3 0;
#X connect 13 0 5 0;
#X connect 15 0 4 1;
#X connect 17 0 4 0;
#X restore 721 549 pd subDivisionRamp;
#X text 334 650 tabread~ starts its indexing from 1 ????;
#N canvas 0 23 450 300 speed&reversePhaseScale 0;
#X obj 37 37 inlet~;
#N canvas 833 23 742 751 read_speedPat 0;
#X obj 37 37 inlet~;
#X obj 38 444 clip~ 0 1;
#X obj 37 359 +~ 1;
#X text 67 360 tabread~ starts its indexing from 1 ????;
#X obj 239 129 expr~ floor($v1);
#X text 342 127 this just ensures we only get integer values (i.e.
counting numbers so we can count the beats);
#X text 98 445 dont let out of bounds values through;
#X obj 38 588 outlet~;
#X obj 38 423 tabread4~ \$0-speedPat;
#X text 129 467 I chose 4 as the maximum speed possible;
#X obj 38 514 expr~ if($v1 < 0.5 \, 1 \, $v1);
#X text 205 513 this just means A) 0 on the graph is 1(i.e. normal
playback) (everything below 0.5 playback speed is output as 1);
#X obj 38 468 *~ 5, f 14;
#X obj 35 208 *~;
#X obj 123 180 t b f;
#X msg 123 201 1;
#X obj 133 227 -;
#X obj 239 284 *~ 1;
#X floatatom 133 248 5 0 0 0 - - -;
#X obj 71 154 r \$0-speedramps_snd;
#X connect 0 0 4 0;
#X connect 0 0 13 0;
#X connect 1 0 12 0;
#X connect 2 0 8 0;
#X connect 4 0 17 0;
#X connect 8 0 1 0;
#X connect 10 0 7 0;
#X connect 12 0 10 0;
#X connect 13 0 2 0;
#X connect 14 0 15 0;
#X connect 14 1 16 1;
#X connect 15 0 16 0;
#X connect 16 0 17 1;
#X connect 16 0 18 0;
#X connect 17 0 2 0;
#X connect 19 0 14 0;
#X connect 19 0 13 1;
#X restore 179 59 pd read_speedPat;
#X obj 37 82 *~, f 11;
#N canvas 833 152 537 386 read_revPat 0;
#X obj 37 37 inlet~;
#X obj 38 201 clip~ 0 1;
#X obj 37 116 +~ 1;
#X text 67 117 tabread~ starts its indexing from 1 ????;
#X obj 37 61 expr~ floor($v1);
#X text 140 59 this just ensures we only get integer values (i.e. counting
numbers so we can count the beats);
#X text 98 202 dont let out of bounds values through;
#X obj 38 346 outlet~;
#X obj 38 180 tabread4~ \$0-revPat;
#X obj 38 268 *~ -2;
#X obj 38 289 +~ 1;
#X obj 38 246 expr~ round($v1);
#X text 146 257 little bit of math to make 0 == 1 (forward) \; and
1 == -1(reverse);
#X connect 0 0 4 0;
#X connect 1 0 11 0;
#X connect 2 0 8 0;
#X connect 4 0 2 0;
#X connect 8 0 1 0;
#X connect 9 0 10 0;
#X connect 10 0 7 0;
#X connect 11 0 9 0;
#X restore 299 59 pd read_revPat;
#X obj 36 107 *~, f 36;
#X obj 181 28 inlet~;
#X obj 36 128 outlet~;
#X text 175 9 phase 0 --> nSteps;
#X text 5 11 phase 0 --> 1;
#X text 11 23 for each sub division;
#X connect 0 0 2 0;
#X connect 1 0 2 1;
#X connect 2 0 4 0;
#X connect 3 0 4 1;
#X connect 4 0 6 0;
#X connect 5 0 1 0;
#X connect 5 0 3 0;
#X restore 305 502 pd speed&reversePhaseScale;
#N canvas 0 23 463 413 2stage 0;
#X obj 37 37 inlet~;
#X obj 37 185 phaseEnv_sjf~;
#X obj 110 247 *~;
#X obj 173 231 phaseEnv_sjf~;
#X obj 260 172 * 0.5;
#X text 36 13 phase 0 --> 1 for subdivision;
#X obj 115 88 inlet~;
#X text 40 63 phase 0 --> 1 for subdivision w/ speed change;
#X obj 110 268 outlet~;
#X text 107 284 amp env;
#X obj 185 124 inlet;
#X obj 264 142 inlet;
#X text 259 124 duckTime (ms);
#X text 177 105 sliceSize(ms);
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 8 0;
#X connect 3 0 2 1;
#X connect 4 0 3 2;
#X connect 6 0 3 0;
#X connect 10 0 1 1;
#X connect 10 0 3 1;
#X connect 11 0 4 0;
#X connect 11 0 1 2;
#X restore 93 616 pd 2stage AmplifierEnvelope;
#X text 12 31 phase 0 --> nSteps;
#X obj 153 43 inlet;
#X obj 263 48 inlet;
#X obj 387 44 inlet;
#X obj 612 44 inlet;
#X text 570 29 sliceSizeSamps;
#X text 151 20 sliceSizeSec;
#X text 269 27 duck Time;
#X text 386 21 nSteps;
#X obj 861 33 inlet;
#X text 862 14 nSlices;
#X obj 92 697 outlet~;
#N canvas 0 23 712 352 read_ampPat 0;
#X obj 38 20 inlet~;
#X text 32 1 phase 0 --> nSteps;
#X obj 38 201 clip~ 0 1;
#X obj 37 116 +~ 1;
#X text 67 117 tabread~ starts its indexing from 1 ????;
#X obj 37 61 expr~ floor($v1);
#X text 140 59 this just ensures we only get integer values (i.e. counting
numbers so we can count the beats);
#X text 98 202 dont let out of bounds values through;
#X obj 38 180 tabread4~ \$0-ampPat;
#X obj 38 222 outlet~;
#X connect 0 0 5 0;
#X connect 2 0 9 0;
#X connect 3 0 8 0;
#X connect 5 0 3 0;
#X connect 8 0 2 0;
#X restore 38 515 pd read_ampPat;
#X obj 30 650 *~, f 11;
#X obj 1100 49 inlet;
#X text 1102 30 subDivTrail;
#X connect 0 0 3 0;
#X connect 1 0 19 0;
#X connect 2 0 7 0;
#X connect 3 0 5 0;
#X connect 3 0 13 0;
#X connect 3 0 12 0;
#X connect 3 0 21 0;
#X connect 3 0 23 1;
#X connect 3 0 37 0;
#X connect 4 0 36 0;
#X connect 5 0 8 0;
#X connect 6 0 23 0;
#X connect 6 0 24 0;
#X connect 7 0 1 0;
#X connect 8 0 6 0;
#X connect 8 0 21 1;
#X connect 9 0 24 2;
#X connect 12 0 2 1;
#X connect 13 0 8 1;
#X connect 13 0 20 1;
#X connect 13 0 21 2;
#X connect 16 0 20 0;
#X connect 16 0 24 1;
#X connect 19 0 4 1;
#X connect 20 0 2 0;
#X connect 21 0 19 1;
#X connect 23 0 16 0;
#X connect 24 0 38 1;
#X connect 26 0 9 0;
#X connect 27 0 24 3;
#X connect 28 0 3 1;
#X connect 29 0 20 2;
#X connect 29 0 12 2;
#X connect 34 0 12 1;
#X connect 37 0 38 0;
#X connect 38 0 4 0;
#X connect 39 0 21 3;
#X restore 110 542 pd samplerLogic;
#X f 25;
#X obj 161 422 r \$0-sliceSizeSec;
#X obj 168 441 r \$0-duckT_snd;
#X obj 176 459 r \$0-nSteps_snd;
#X obj 195 477 r \$0-sliceSizeSamps;
#X obj 217 495 r \$0-nSlices_snd;
#X obj 236 514 r \$0-trail_snd;
#X obj 366 234 hsl 145 15 0 2 0 1 \$0-trail_snd \$0-trail_rec trail_amp_curve
5 8 0 10 -262144 -1 -1 6100 1;
#X obj 845 480 loadbang;
#X msg 785 639 16;
#X obj 785 659 s \$0-nSlices_rec;
#X obj 886 659 s \$0-nSteps_rec;
#X msg 886 638 16;
#X msg 980 638 5;
#X obj 980 659 s \$0-duckT_rec;
#X obj 598 186 vsl 15 100 0 1 0 1 \$0-vol_snd \$0-vol_rec vol 0 -9
0 10 -262144 -1 -1 9900 1;
#X obj 187 585 r \$0-vol_snd;
#X obj 13 6 r \$0-original_snd;
#N canvas 0 23 450 300 phasor~_freq_logic 0;
#X obj 96 50 t b f;
#X obj 96 31 r \$0-nSteps_snd;
#X obj 88 9 r \$0-sliceSizeSec;
#N canvas 0 23 450 300 1/\$1 0;
#X obj 93 65 t b f;
#X msg 93 86 1;
#X obj 93 107 /, f 5;
#X obj 95 39 inlet;
#X obj 93 128 outlet;
#X connect 0 0 1 0;
#X connect 0 1 2 1;
#X connect 1 0 2 0;
#X connect 2 0 4 0;
#X connect 3 0 0 0;
#X restore 88 94 pd 1/\$1;
#X obj 88 74 * 1;
#X obj 88 200 *, f 17;
#X obj 146 178 t b f;
#X obj 146 153 r \$0-tempoQuantize;
#X obj 88 221 outlet;
#X connect 0 0 4 0;
#X connect 0 1 4 1;
#X connect 1 0 0 0;
#X connect 2 0 4 0;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 5 0 8 0;
#X connect 6 0 5 0;
#X connect 6 1 5 1;
#X connect 7 0 6 0;
#X restore 111 320 pd phasor~_freq_logic;
#N canvas 0 23 595 300 reset_2_original_logic 0;
#X obj 192 9 r \$0-original_snd;
#X obj 192 126 until;
#N canvas 56 23 816 536 simpleCounter 0;
#X obj 385 98 +;
#X msg 509 45 0;
#X msg 385 59 0;
#X obj 454 178 + 1;
#X obj 385 41 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X floatatom 385 263 5 0 0 0 - - -;
#X obj 385 158 % 8;
#X text 536 43 reset;
#X floatatom 597 43 5 0 0 0 - - -;
#X text 630 42 #beats in count;
#X obj 385 8 inlet;
#X obj 385 317 outlet;
#X text 13 58 1 - we want our count to go up by 1 each time \, but
we want to output 0 the first time;
#X text 14 98 2 - the 0 is added to the previous count (which starts
at 0 because there is no argument after '+');
#X text 14 153 3 - the count is passed through a modulo object (which
divides the output by 8 (due to the argument) and then outputs the
remainder.;
#X obj 509 8 inlet;
#X obj 597 8 inlet;
#X text 13 206 4 - the remainder is output from the right output of
the trigger first \, it has 1 added to it (right outlet) and then the
new count is stored for the next trigger;
#X text 14 256 5 - The count is then displayed (not 100% necessary)
;
#X obj 385 214 t f f;
#X connect 0 0 6 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 3 0 0 1;
#X connect 4 0 2 0;
#X connect 5 0 11 0;
#X connect 6 0 19 0;
#X connect 8 0 6 1;
#X connect 10 0 4 0;
#X connect 15 0 1 0;
#X connect 16 0 8 0;
#X connect 19 0 5 0;
#X connect 19 1 3 0;
#X restore 192 145 pd simpleCounter;
#X obj 192 105 t f b f, f 10;
#X obj 192 166 + 1, f 5;
#X obj 139 245 tabwrite \$0-subDivPat;
#X obj 272 245 tabwrite \$0-speedPat;
#X obj 241 188 tabwrite \$0-ampPat;
#X obj 21 246 tabwrite \$0-revPat;
#X obj 400 245 tabwrite \$0-trailTypePat;
#X obj 301 35 r \$0-nSteps_snd;
#X msg 192 187 0 \$1, f 5;
#X obj 192 81 int, f 19;
#X msg 241 167 1 \$1, f 5;
#X obj 390 147 s \$0-nSteps_rec;
#X obj 393 66 int;
#X obj 192 30 t b b;
#X obj 407 37 r \$0-nSlices_snd;
#X obj 390 102 t f f;
#X connect 0 0 16 0;
#X connect 1 0 2 0;
#X connect 2 0 4 0;
#X connect 3 0 1 0;
#X connect 3 1 2 1;
#X connect 3 2 2 2;
#X connect 4 0 11 0;
#X connect 4 0 13 0;
#X connect 10 0 12 1;
#X connect 11 0 5 0;
#X connect 11 0 6 0;
#X connect 11 0 8 0;
#X connect 11 0 9 0;
#X connect 12 0 3 0;
#X connect 13 0 7 0;
#X connect 16 0 12 0;
#X connect 16 1 15 0;
#X connect 17 0 15 1;
#X connect 18 0 14 0;
#X connect 18 1 12 1;
#X restore 149 660 pd reset_2_original_logic;
#X floatatom 578 260 3 1 64 0 sliceVal_1/ #0-sliceVal_rec #0-sliceVal_snd
;
#X obj 975 604 s \$0-sliceVal_rec;
#X msg 975 583 8;
#X obj 110 622 outlet~;
#X floatatom 287 547 5 0 0 0 - - -;
#X obj 529 501 t b f;
#X obj 529 522 s \$0-original_snd;
#X obj 49 443 inlet~;
#X obj 901 547 t b b b b b;
#X obj 844 512 t b b;
#X obj 364 257 tgl 15 1 \$0-speedramps_snd \$0-speedramps_rec speed_ramps
17 7 0 10 -262144 -1 -1 0 1;
#X obj 364 273 tgl 15 1 \$0-subDivramps_snd \$0-subDivramps_rec subDiv_ramps
17 7 0 10 -262144 -1 -1 0 1;
#X obj 111 422 *~;
#X obj 126 402 r \$0-on/off_snd;
#X obj 537 154 bng 15 250 50 0 \$0-rand_snd \$0-rand_rec rand -20 7
0 8 -262144 -1 -1;
#X obj 783 550 int \$0;
#X obj 783 571 outlet;
#X text 773 589 unique id;
#X obj 785 511 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 1124 378 tgl 15 1 empty \$0-dsp_rec dsp 17 7 0 10 -262144 -1
-1 1 1;
#X obj 1124 398 switch~;
#X msg 928 489 1;
#X obj 928 509 s \$0-dsp_rec;
#X msg 1030 543 1;
#X obj 1030 564 s \$0-on/off_rec;
#X connect 1 0 3 0;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 6 0 7 0;
#X connect 8 0 3 0;
#X connect 9 0 3 0;
#X connect 10 0 3 0;
#X connect 11 0 72 0;
#X connect 12 0 70 0;
#X connect 15 0 11 0;
#X connect 17 0 11 0;
#X connect 19 0 79 0;
#X connect 34 0 33 2;
#X connect 35 0 33 1;
#X connect 36 0 27 0;
#X connect 36 0 46 1;
#X connect 36 1 22 0;
#X connect 37 0 36 1;
#X connect 42 0 44 0;
#X connect 43 0 42 0;
#X connect 45 0 46 0;
#X connect 46 0 40 0;
#X connect 46 1 42 1;
#X connect 47 0 12 0;
#X connect 48 0 47 1;
#X connect 49 0 47 2;
#X connect 50 0 47 3;
#X connect 51 0 47 4;
#X connect 52 0 47 5;
#X connect 53 0 47 6;
#X connect 53 0 71 0;
#X connect 55 0 76 0;
#X connect 56 0 57 0;
#X connect 59 0 58 0;
#X connect 60 0 61 0;
#X connect 63 0 12 1;
#X connect 64 0 33 0;
#X connect 65 0 19 0;
#X connect 69 0 68 0;
#X connect 72 0 73 0;
#X connect 72 1 36 0;
#X connect 74 0 47 0;
#X connect 75 0 56 0;
#X connect 75 1 59 0;
#X connect 75 2 60 0;
#X connect 75 3 69 0;
#X connect 75 4 90 0;
#X connect 76 0 8 0;
#X connect 76 0 82 0;
#X connect 76 1 75 0;
#X connect 76 1 88 0;
#X connect 79 0 47 0;
#X connect 80 0 79 1;
#X connect 82 0 83 0;
#X connect 85 0 82 0;
#X connect 86 0 87 0;
#X connect 88 0 89 0;
#X connect 90 0 91 0;
#X coords 0 -1 1 1 906 260 1 10 30;
